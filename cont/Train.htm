<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>Обучение</title>
<LINK REL="stylesheet" MEDIA="screen" TYPE="text/css" HREF="../style.css">
<script language="JScript" src="../rec/script.js"></script></head>
<body scroll="no">
<DIV id="buttonMenu">
<SPAN CLASS="options">Разделы:&nbsp;&nbsp;</SPAN>
 <A HREF="#basic" title="Основы - общий формат команд" CLASS="button">1</A>
 <A HREF="#1" title="Как создать свой первый скрипт: часть 1" CLASS="button">2</A>
 <A HREF="#2" title="Как создать свой первый скрипт: часть 2" CLASS="button">3</A>
 <A HREF="#3" title="Как создать свой первый скрипт: часть 3" CLASS="button">4</A>
 
 <A HREF="#stone" title="Поющий камень" CLASS="button">5</a>
 <A HREF="#8" title="Размещения жилищ 8го уровня" CLASS="button">6</a>
 <A HREF="#mithril" title="Показ мифрила при подборе, и его общее кол-во" CLASS="button">7</a>
 <a href="#exp" title="Добавление существам линий опыта" class="button">8</a>
	<A style="position:absolute; right:4" href="#UP" CLASS="button" title="Вернуться к началу">&uarr;</a>

</DIV>

<DIV id="text">
<a name="up"></a>
<h1 align="center">Обучение</h1>
<a name="Basic"></a><h2>Основы <font size="4">(общий формат)</font></h2>
<p align="left">Все триггеры, ресиверы и инструкции имеют общий формат: 
Заголовок [:Тело] ;<br>
Опциональные элементы - в квадратных скобках. В частности, триггеры не имеют 
тела.<br>
Заголовок содержит информацию о цели команды: Триггер (T), Ресивер (Р) или 
Инструкция (И), также он содержит дополнительную информацию об исполняемом 
объекте.<br>
Тело содержит исполняемые ERM-команды, соответствующие 
типу объекта (Р или И).<br>
Все ресиверы и инструкции должны иметь как минимум один параметр 
для корректной работы.</p>
<p><b>Заголовок</b> имеет следующий формат: !{?|!|#}AB [ Идентификатор ] [ Условия ]<br>
Выберите один из разделённых &quot;|&quot; элементов из скобок ( '?','!','#'- означают Триггер, Ресивер, Инструкцию соответственно ).<br>
'AB' определяет тип Т, Р или И (см. дальше).<br>
Идентификатор - номер определённого объекта.<br>
Условия - условия &quot;выполнения&quot; дальнейшей части (тела) для Р и И или всех 
ресиверов триггера.<br>
Если условий нет, Т, Р, И выполняются без проверок.</p>
<p><b>Идентификаторы</b> имеют следующий формат: N[/N[/N[&hellip;]]]<br>
Символы 'N' означают целые числа, значение которых зависит от типа Т, Р, И (см. 
дальше).</p>
<p><b>Условия</b> имеют следующий формат: &amp;N[/N[/N[&hellip;]]]<br>
Символ '&amp;' отделяет числа условия от идентификатора.<br>
Выполнение может зависеть от флагов (Ф) (общее их число - 1000). Если вы желаете 
сделать Т, Р или И зависимой от флага, вы должны вставить его номер (1..1000) 
вместо N.<br>
Если номер флага положителен, тогда условие - &quot;флаг активирован (Истина)&quot;, если 
отрицательный - &quot;флаг деактивирован (Ложь)&quot;.<br>
<a href="../Rec/VR.htm">Сравнение переменных</a> также может использоваться как условие выполнения.</p>
<p>Тело имеет формат, зависящий от типа T, Р, И (см. <a href="#ТРИ">дальше</a>).</p>
<p>Если параметр команды показан как $ - 
значение можно сохранить в переменную. Если показан как # - её можно только 
установить, но не прочитать. Если он показан как ?$ - его можно лишь прочитать, 
но не установить.</p>
<p><u>Пример</u>:
<script type="erm">!!LE10/33/1&1/-2/5:E500 O2 L0;</script>
Это ресивер типа <a href="../Rec/LE.htm">LE</a> (событие на карте) с координатами <b>X</b>=10, <b>Y</b>=33, 
<b>Уровень</b>=Подземелье. Тело имеет 3 команды: E, O и L (см: <a href="../Rec/LE.htm">ресивер LE</a>). 
Эти команды (в теле) выполнятся, только лишь если в момент 
выполнения 1ый и 5ый флаги будут Истина, а 2 - Ложь. Иначе, ничего не выполнится.</p>

<h3><a name="ТРИ"></a>Триггеры, ресиверы и инструкции</h3>
<p>Когда игрок активирует триггер, он вызывает один или множество 
ресиверов. Триггером может быть событие, объект или герой-посетитель, или это 
может быть ERM-функция, вызываемая другим ERM-кодом 
или даже таймер, установленный на срабатывание в определённый интервал времени 
(например, каждые 14 дней). Параметры триггера или объекта не влияют на 
предназначение триггера. Действие триггера должно быть описано во временно&#x301;м 
событии. Инструкции используют практически тот же формат, что и ресиверы, за 
исключением того, что отличаются в начале кода. В отличие от ресиверов, 
Инструкции выполняются лишь единожды, при загрузке карты.</p>
<p>Для детальной информации о триггерах, см.
<a href="TriggerSol.htm">Триггеры</a>.<br>
Для детальной информации о ресиверах, см. <a href="ReceiverSol.htm">Ресиверы</a>.</p>
<p><b>Разное</b><br>
Вы не можете использовать &quot;;&quot; или &quot;^&quot; внутри текстовых сообщений (текст, 
заключенный в &quot;^&quot; выводится на экран).<br>
Так, ^Это сообщение, понятно?^ правильно.<br>
А ^Это сообщение<b><code>;</code></b> понятно?^ некорректно.</p>

<h2><a name="1"></a>Как создать свой первый скрипт<br>ERM для чайников, <b id="N1">Qurqirish Dragon</b></h2>
<p>Первое, что вы должны знать в любом случае - скрипт должен помещаться в карте во 
временны&#x301;х событиях. Для этого зайдите в редактор карт, заходите в &quot;Спецификации 
карты&quot; и нажмите на табличку &quot;События&quot;.</p>
<p>Поскольку вам не нужно, чтобы скрипт показывался как обычное сообщение, 
запретите всем игрокам-людям возможность его активирования.</p>
<p>Также рекомендуется использовать наибольший день появления (672). В этом 
случае будет удобней заходить в событие, находящееся в конце списка, да и редко 
карта длится дольше года.</p>
<p>Наконец, вы должны дать имя событию и описанию скрипта.<br>
Теперь вставьте скрипт в сообщение события. Вы можете делать скрипт прямо здесь 
или в скрипт-редакторе и затем вставлять его в окно события.<br>
Если вы будете использовать скрипт-редактор, это поможет вам избежать ошибок 
кода:<ol id="T0">
<li>Если вы сделаете какие-либо изменения в скрипте, снова сохраните его;</li>
<li>Выберите целый скрипт - <span class="key">Ctrl</span>+<span class="key">A</span> - и скопируйте его - <span class="key">Ctrl</span>+<span class="key">C</span>;</li>
<li>Идите в редактор карт, и вставляйте скрипт - <span class="key">Ctrl</span>+<span class="key">V</span>.</li></ol>
Если вы используете любой другой редактор (типа блокнота), чтобы написать 
скрипт, затем откройте скрипт-редактор, скопируйте туда скрипт и сохраните. 
Многие редакторы - особенно WordPad помещают невидимые символы и визуальные коды 
в файл, и это может привести к ошибкам ERM.</p>
<p align="center">* * *</p>
<p>
Теперь собственно о скриптинге. Я приму за факт, что вы используете последнюю 
версию ERM-редактора, и включили подсветку команд (кнопка 'H' у основания окна 
редактора). Кроме того, я не буду предполагать, знаете ли вы ЧТО-НИБУДЬ, из 
того, что я напишу здесь.</p>
<p>Первое - каждый раз, когда вы работаете над скриптом, я предлагаю писать на 
листе бумаги - именно на листе, не в текстовом редакторе, - требования к скрипту, 
т.е. его действия. Сделайте &quot;мозговую атаку&quot;, чтобы понять, что именно вы хотите 
от скрипта.</p>
<p>Например, я написал скрипт Карт Пророчества (<i class="file">Папка_героев/data/s/script34.erm</i>) 
для игры с параметрами героя при начале сражения. К счастью, у меня были мои 
примечания относительно скрипта, и могу разделить их здесь. Заметьте, что когда 
я начинал скрипт, я прежде ВООБЩЕ не видел ERM-скриптинга.</p>
<p>Сначала я записал это:<br>
Артефакт, который в начале каждой битвы даёт от -1 до +4 очка случайного 
первичного навыка.<br>
Это было целой идеей. Выглядит просто, правда? Я думал также. Затем я описал 
основные шаги:<br>
Начало битвы - проверка на артефакт. Имеется?<br>
нет - выход<br>
да - установить флаг, выбрать случайный номер параметра (1, 2, 3, 4)</p>
<p>И так далее, только общий эскиз. Я больше не буду входить в детали, я только 
хотел показать вам, что желательно сделать перед скриптописанием. Поверьте - 
если вы сделаете это сразу, то дальше будет намного легче.</p>

<p><u>Теперь время писать код</u>!<br>
Первая строка скрипта:<br>
<b><code><a target="form" href="ZVSE.htm">ZVSE</a></code></b><br>
Это говорит WoG'у, что это не простое событие, а скрипт. Без этой строки вся ваша 
работа будет игнорироваться игрой.<br>
Все команды состоят из четырех символов, и одного из трех основных типов, не 
включая ZVSE. В редакторе скриптов команды подсвечиваются разными цветами.</p>
<p><b>Триггеры</b> - команды, которые означают &quot;Если что-то происходит в игре, я начинаю 
работу&quot;. Все триггеры начинаются со знаков <b>!?</b><br>
Например, возьмите эту линию кода из моего скрипта Карт (помните, скрипт 34):<br>
<b id="erm"><a href="../Tr/BA.htm" class="tr">!?BA</a>0&amp;v1321=1; 
<font class="co">[начало битвы]</font></b><br>
Это первый триггер в моем скрипте. Не беспокойтесь о действии команды, я объясню 
действие попозже. Но заметьте точку с запятой в конце строки (;). Все ERM-команды 
оканчиваются точкой с запятой (!). После этого знака дальнейший текст считается 
комментарием, здесь он будет окрашиваться <font color=#008000 class="erm">зелёным</font>.</p>
<p><b>Ресиверы</b> - команды, которые устанавливают, проверяют или изменяют что-либо в 
игре. Они не сработают, если перед ними нет триггера. Все ресиверы начинаются с <b>!!</b><br>
Пример:<br>
<b id="erm"><a href="../Rec/BA.htm" class="re">!!BA</a>:E?v1331; 
<font class="co">[проверить на мультиплеерную игру]</font></b><br>
Опять заметьте точку с запятой в конце команды. В комментарии вы можете 
объяснить значение команды, но об этом позже.</p>
<p>Наконец, <b>инструкции</b> - как и ресиверы, за исключением того, что они работают 
только один раз - при начале карты. Они начинаются на <b>!#</b><br>
Пример:<br>
<b id="erm"><a href="../Rec/UN.htm" class="in">!#UN</a>:P34/?v1321; 
<font class="co">[скрипт включен?]</font></b><br>
Для тех, кто смотрит на мой скрипт: отметьте, что есть и просто "зелёные" строки - 
комментарии. Для этого я использовал **. это необходимо, и другие авторы ERM 
используют в большинстве такой же метод. Пока вы не начинаете строку с команды, 
ERМ игнорирует её.</p>
<p>Для закругления введения, я объясню вам пару простых команд, с помощью каких вы 
сможете сделать что-нибудь. Второй урок даст немного больше - но не бойтесь 
экспериментировать.</p>
<p>Этот скрипт просто рассчитает, как часто герои посещали левый верхний угол 
верхнего уровня карты (координаты 0, 0, 0). Всякий раз, когда я ввожу команды, я 
всегда включаю ERM-помощь.</p>
<p>Первая линия, конечно:<br>
<b><code><a target="form" href="ZVSE.htm">ZVSE</a></code></b><br>
Далее, мы должны установить счётчик на 0. Так как мы хотим начать счёт с 0, нам 
нужна инструкция. Инструкция должна быть назначена на переменную (<b id="erm"><a href="../Rec/VR.htm" class="in">!#VR</a></b>)<br>
Прежде чем двигаться дальше, мы должны выбрать переменную для записи счёта. 
Обычно вы должны сверяться со списком <a href="UsedVar.htm">использованных переменных</a>, находящихся там же, где и 
скрипты, и выбрать неиспользованную переменную. Но в целях обучения я буду 
всегда пользоваться <i>v</i>-переменными с малыми номерами.<br>
V-переменные - это те, которые вы будете использовать чаще всего. Я введу другие типы по необходимости.<br>
Так, теперь используем команду:
<script type="erm">!#VRv1:S0;</script>
Давайте разберём, что есть что:<br>
<table class="one" cellpadding=3 style="margin:5">
	<tr><td width=40><font color="#808000"><b>!#VR</b></font></td>
	<td>Выполнить команду в начале карты, команда работает с переменными</td></tr>
	<tr><td><b>v1</b></td>
	<td>Операция проходит над переменной v1</td></tr>
	<tr><td><b>:</b></td>
	<td>Любая команда, которая что-либо делает, используется двоеточие для отделения команды от опции.
	Триггеры не имеют этого знака, но остальные - имеют.</td></tr>
	<tr><td><b>S0</b></td>
	<td>Выбрать опцию S для команды VR. Это сообщает, что вы хотите установить значение переменной. 
	В данном случае мы устанавливает его на 0.</td></tr>
	<tr><td><b>;</b></td>
	<td>Как я упоминал выше, точка с запятой оканчивает команду.</td></tr>
</table></p>
<p>Теперь мы должны установить триггер. На карте поместите событие в координатах [0,0,0]. Это 
нужно, чтобы позволить всем игрокам активировать событие, и позволить событию 
повторяться несколько раз.</p>
<p>Теперь установим триггер:
<script type="erm">!?LE0/0/0;</script>
<a href="../Tr/LE.htm">Триггер LE</a> - &quot;<i>Когда событие в данных координатах активируется&hellip;</i>&quot; Эти три числа 
- координаты соответственно x, y и уровня. Если вы откроете помощь для триггера 
!?LE, вы заметите, что также есть триггер !$LE (знак <b>$</b> вместо <b>?</b>). Это - &quot;<i>После 
того, как событие в координатах посещено&hellip;</i>&quot;. Если событие на карте делает 
что-либо без ERM, вы можете запустить его до или после кода (соответственно <b>!$</b> и <b>!?</b>). 
В нашем случае это не имеет значения, т.к. событие пустое.</p>
<p>Далее, теперь мы должны добавить единицу к значению. Для этого используем другую 
опцию команды VR, но теперь мы используем ресивер (<b>!!</b> вместо <b>!#</b>):
<script type="erm">!!VRv1:+1;</script>
ERM использует &quot;<b>+</b>&quot; для указания действия прибавления. Таким образом, эта команда 
обозначает &quot;<i>добавить 1 к переменной v1</i>&quot;.<br>Другие математические операции:
<ul id="T0">
<li>уменьшение: используйте &quot;<b>-</b>&quot;</li>
<li>умножение: используйте &quot;<b>*</b>&quot;</li>
<li>деление: используйте &quot;<b>:</b>&quot;</li>
<li>получить остаток от деления: используйте &quot;<b>%</b>&quot;</li></ul>
Заметьте, что кроме <i>e</i>-переменных все числа целые, т.е. 7, разделённое на 4, 
будет равняться 1, а не 1,75.</p>
<p>Наконец, мы должны показать сообщение игроку, в котором будет указано, какой раз посещается это место:
<script type="erm">!!IF:M^Вы %V1 посетитель этого северо-западного угла поверхности!^;</script>
<a href="../Rec/IF.htm">IF</a> - команда для диалогов с игроком. Они могут быть простыми, как обычное 
сообщение, или задавать вопросы, показывать картинки и даже давать выбор.<br>
Опция M - &quot;<i>Показ сообщения</i>&quot;. Есть только несколько ограничений того, что может 
быть в сообщении. Вы не можете использовать &quot;^&quot; или &quot;;&quot;. Вы также должны быть 
осторожны с процентом. Если вы хотите показать знак <b>%</b>, вы должны напечатать <b>%%</b>.<br>
Вы, вероятно, заметили, что в сообщении есть %. Если вы используете один %, то 
дальше должны написать, что (какую переменную) хотите показать. В данном случае 
%V1 (заметьте, что здесь вместо строчных букв используются Заглавные): вместо 
этих символов будет показано значение переменной v1. Если вы посмотрите на 
<a href="../Rec/IF.htm#more">ресивер IF</a>, вы увидите список команд для %.</p>
<p>Это весь скрипт.<br>Так, объединяя всё вместе, мы получаем следующее:
<script type="erm">ZVSE
!#VRv1:S0; [установить переменную v1 на 0]
!?LE0/0/0; [посещение события в северо-западном углу поверхности]
!!VRv1:+1; [добавить 1 к v1]
!!IF:M^Вы %V1 посетитель этого северо-западного угла поверхности!^; [показать сообщение]</script></p>
	
<h2><a name="2"></a>Как создать свой первый скрипт #2<br>ERM для чайников, <b id="N1">Qurqirish Dragon</b></h2>
<p>Я собираюсь взять скрипт, сделанный ранее, и расширить его действие - 
каждый герой, посещающий северо-западный угол карты в десятый раз, станет сказочно 
сильным, слабым или обычным (циклически). Другими словами, после того, как 10 
героев посетят событие, все герои удвоят свою силу магии во время битвы. После 
20го сила магии в бою будет установлена на 1, и после 30го станет обычной. Затем 
цикл повторится.</p>
<p>Сначала мы собираемся вставить строку, между командами !!VR и !!IF. Эта строка 
проверит на то, какой по счёту вы посетитель. Так как это значение необходимо, 
чтобы сохранять счёт, я использую временную переменную. Временные переменные в 
ERM - это <i>y</i>-переменные. Они не сохраняются между скриптами, так что вы не можете 
использовать эту переменную для длительного хранения. Но зато вы можете не 
беспокоиться о том, что испортите другие скрипты, используя эти переменные.<br>
Так, давайте добавим строку:<script type="erm">!!VRy1:Sv1 %10; [записать остаток от деления v1 на 10 в y1]</script></p>
<p>Эта команда использует два оператора в одной команд. Все действия в ERM идут 
слева направо. Помните, что если у вас несколько операций для выполнения - лучше 
разбить их на несколько строк. В этом случае мы сначала устанавливаем переменную 
y1 в значение переменной v1, и затем находим остаток при делении на 10. Если y1 = 0, значит v1 - число, кратное 10.</p>
<p>Теперь, если это число не кратно 10, мы должны только показать сообщение, уже 
указанное прежде. Нужно сделать небольшое изменение:
<script type="erm">!!IF&y1&<>0:M^Вы %V1 посетитель этого северо-западного угла поверхности!^;  [показать это сообщение, если ничего более не происходит]</script></p>
<p>Кроме изменения в комментарии, я добавил перед двоеточием условие &amp; (амперсанд) 
и y1&lt;&gt;0. Амперсанд - &quot;позволю команде работать, если мое условие выполнено&quot;.</p>
<p>Дальнейшее выражение y1&lt;&gt;0 говорит об условии (здесь нужно, чтобы y1 был больше 
или меньше 0). Таким образом это сообщение будет показано только если y1 больше 
или меньше 0.</p>
<p>Теперь, если v1 - число, кратное десяти, мы хотим сообщить, что волшебство 
изменяет мир. Но для этого мы должны узнать, какое изменение делается. Мы будем 
использовать другую <i>y</i>-переменную для проверки на это:
<script type="erm">!!VRy2:Sv1 :10 %3;  [найти номер изменения]</script></p>
<p>Эта команда возьмет v1 и разделит его на 10, затем возьмет остаток при делении 
на 3. Это даст значение переменной y2: если v1 будет меньше 10 или между 30 и 
39, 60 и 69 и т.д., то значение y2 будет равно 0. y2 будет равно 1, если v1 
будет между 10 и 19, 40 и 49 и т.д., и тот же принцип при y2 = 2. Заметьте, что 
даже если v1 - число, не кратное 10, оно всё равно посчитается.</p>
<p>Теперь нам нужно ещё три команды !!IF - одна для каждого типа изменения. Но я 
могу ввести ещё несколько понятий, при этом пойдя по чуть более длинному пути.<br>
Нам нужно сообщение, в котором говорится &quot;Вы [число] посетитель, вы чувствуете, 
что сила магии в мире увеличилась!&quot;<br>
Также нужно сообщение, содержащее &quot;Вы [число] посетитель, вы чувствуете, что 
сила магии в мире ослабевает.&quot;<br>
И последнее, что нам нужно: &quot;Вы [число] посетитель, вы чувствуете, что магия в 
мире стабилизируется.&quot;<br>
Заметьте, что эти три предложения говорят почти одно и то же самое, но с 
небольшими изменениями. Нам точно не нужны лишние символы. Это особо важно, если 
позже мы захотим добавить больше возможностей.</p>
<p>Для этого мы собираемся использовать <i>z</i>-переменную.<br>
<a href="Flags.htm#z">Z-переменные</a> - единственные 
переменные, способные хранить текстовые данные. Точно так же, как и 
<i>v</i>-переменные, <i>z</i>-переменные постоянно сохраняются.<br>
Но есть несколько <i>z</i>-переменных, являющиеся временными, как <i>y</i>-переменные. Быстрый 
взгляд на &quot;<a href="Flags.htm#Var_typ">Флаги и переменные</a>&quot; в ERM-помощи, и вам 
известно, что временные <i>z</i>-переменные обозначаются немного по-другому: от z-1 до 
z-10. Давайте используем переменную z-1, чтобы записать кусок текста, который 
изменяется.<br>
Это будет три строки:
<script type="erm">!!VRz-1&y2=0:S^сила магии в мире увеличилась!^;  [для визита 30, 60, 90, ...]
!!VRz-1&y2=1:S^сила магии в мире ослабевает!^;  [для визита 10, 40, 70, ...]
!!VRz-1&y2=2:S^магия в мире стабилизируется!^;  [для визита 20, 50, 80, ...]</script></p>
<p>Здесь вы полностью должны понять эти строчки. Вместе они устанавливают 
переменную z-1 в тот текст, который нужен в данном случае.<br>
Отметьте, что правила помещения текста в <i>z</i>-переменную аналогичны правилам для 
текста в команде !!IF:M, вы можете использовать команду % для показа значения 
других переменных, и вы должны напечатать %% для знака процентов. Символы &quot;^&quot; и 
&quot;;&quot; не позволительны!.</p>
<p>Теперь мы должны показать новое <script type="erm">!!IF&y1=0:M^Вы %V1 посетитель, вы чувствуете, что %Z-1.^;  [показать измененное сообщение]</script></p>
<p>В этот раз условие состоит в том, что y1 равняется 0. Мы только хотим, чтобы это сообщение появилось и изменялось.<br>
Теперь у нас готовы все сообщения. Затем нужен код, чтобы изменить параметры героя в битве.<br>
Я хочу добавить, что строка ниже - комментарий, т.е. в редакторе скриптов будет изображаться &quot;зелёным&quot;:
<script type="erm">;** начало кода эффекта в битвах</script>
Нам нужна проверка на начало битвы. Это означает, что нам нужен новый триггер:
<script type="erm">!?BA0;</script>
Так как мы использовали новый триггер, предыдущий код прекратит работу при 
достижении этого места. Триггер <a href="../Tr/BA.htm">!?BA</a> активируется при битвах. !?BA0 (здесь '0' это &quot;ноль&quot;, а не 'о') 
- триггер на начало сражения. Нам понадобится так же триггер на конец битвы.</p>
<p>Знайте, что многие скрипты часто имеют проблемы в игре человек против человека и 
мультиплеерных битв. Хотя данный скрипт не должен иметь проблем, я всё равно 
собираюсь проверить на этот случай и не позволить коду работать в этом случае.<br>
Есть специальная команда для этой проверки:<script type="erm">!!BA:E?y1;  [это сетевая битва?]</script>
Это <a href="../Rec/BA.htm">ресивер BA</a>. Опция E - &quot;я узнаю, какое это сражение&quot;. В ?y1 запишется 
результат проверки.<br>
Отметьте, что я многократно использую y1 с самого начала - это и есть 
преимущество временных переменных: вы можете не волноваться о старом значении, 
если вы хотите использовать переменную.</p>
<p>Если вы просмотрите ERM-помощь по ресиверу <a href="../Rec/BA.htm">BA</a>, то 
узнаете, что y1 может принимать значения:
<ul id="T0">
<li>Если битва - между ИИ и игроком-человеком, ход ИИ на компьютере хозяина игры, то 
y1 будет равна 2;</li>
<li>Если это битва человек на человека, кроме хот-сита, y1 установится на 1;</li>
<li>Если иначе, то y1 устанавливается на 0.</li></ul>
Теперь нам нужно, чтобы код работал в последнем случае. Пока вы не знаете, какие 
типы скриптов сражений работают в случаях 1 и 2, самое безопасное - сделать это.<br>
Теперь мы имеем следующую строку:<script type="erm">!!FU1&y1=0:Pv1;  [если нет, продолжить скрипт]</script></p>
<p>Это - новый ресивер. <a href="../Rec/FU.htm">Ресивер FU</a> вызывает другие строки кода, в этом случае - 
кода под функцией 1. Опять же, условие для этого - y1 = 0. Иначе функция не 
начнётся.<br>
Опция P означает, что следующие параметры нужно передать в функцию. Хотя в этом 
случае они не необходимы, я передал переменную v1. Это позволит мне управлять 
переменной v1 внутри функции, не изменяя сохранённое значение.<br>
Мы не должны делать что-либо ещё в начале сражения, таким образом мы можем 
перейти прямо к функции.</p>
<p>Мы начинаем триггер функции (<a href="../Tr/FU.htm">!?FU</a>), указывая новую секцию кода вместе с комментариями:
<script type="erm">;** за миг до сражения
!?FU1;</script></p>
<p>Так как мы хотим изменить силу магии каждого героя в сражении, мы должны знать, 
какие герои борются, если они вообще имеются. Это делается двумя ресиверами для 
сражений:
<script type="erm">!!BA:H0/?v5; [получить номер атакующего героя]
!!BA:H1/?v6; [получить номер защищающегося героя]</script></p>
<p>Опция H узнает номер героя. H0 записывает номер нападающего, H1 - защищающегося. 
Если героя-защитника нет, то BA:H1 устанавливается на -2.</p>
<p>Все номера героев перечислены в ERM-помощи, но так как мы применяем это действие 
ко всем героям, мы не заботимся об определённом герое.<br>
Я выбрал переменные v5 и v6 для записи номеров, потому что переменным v3 и v4 я 
оставил другое назначение.</p>
<p>Теперь мы должны узнать силу магии для изменения. Наша <i>y</i>-переменная выше, 
которая хранила силу магии для изменения, уже потеряла своё значение. Но у нас 
есть доступ к переменной v1. Давайте снова получим тип изменения:
<script type="erm">!!VRx1::10 %3;  [получить тип изменения]</script></p>
<p>Это выглядит знакомо, но несколько изменений всё же есть. Первое - использована 
переменная x1, а не v1.<br>
Это потому, что значение переменной v1 теперь сохранилось в x1. <i>x</i>-переменные 
пронумерованы от x1 до x15, и содержат параметры, в которые их передавали 
ресивером FU.<br>
Так как я передал v1, x1 получила своё значение.<br>
Так же существует x16, и вы можете передать значение этой переменной, но она 
имеет особое назначение (дело с которым мы будем иметь чуть позже), т.е. вы 
должны пытаться избегать использования этой переменной. Также отметьте, что эти 
переменные могут содержать только целые числа, т.е. вы не можете передать 
<i>z</i>-переменную.<br>
Кроме того, не волнуйтесь из-за двойного двоеточия. Первое двоеточие отделяет 
команду от опции, а второе - производит операцию деления. Теперь x1 содержит 
значение, которое мы записывали в первой части скрипта.</p>
<p>Теперь мы почти готовы. Мы просто должны узнать силу магии героев:
<script type="erm">!!HEv5:F?y5/?y6/?y3/?y7; [получить параметры атакующего]
!!HEv6&v6>=0:F?y5/?y6/?y4/?y7;  [получить параметры защищающегося]</script></p>
<p><a href="../Rec/HE.htm">Ресивер HE</a> используется для изменений аспектов 
любого героя. Первая строка просматривает героя номер v5, а вторая - v6.</p>
<p>Во второй строке мы добавили проверку v6&gt;=0, чтобы, если нет героя-защитника, WoG 
не пробовал искать героя -2. Это бы вызвало ошибку при запуске скрипта.<br>
Опция F смотрит параметры героя. Следующие четыре числа разделены слэшами &quot;/&quot; - 
атака, защита, сила магии, знания, в именно таком порядке.<br>
Если вы поместите число или переменную туда, это изменит параметр на значение 
числа или переменной. Если вы помещаете знак ? перед именем переменной, тогда 
берётся текущее значение навыка и хранится в этой переменной. В этом случае 
переменные y3 и y4 будут содержать силу магии героев.<br>
Переменные y5, y6, и y7 - просто удерживают значение, и я могу использовать их 
повторно.</p>
<p>Здесь я хочу отметить, что хорошая идея - записывать на отдельной бумаге то, что 
хранит каждая переменная. Это поможет, если вы вдруг это забыли.<br>
Теперь мы должны настроить изменения силы магии. Так как мы должны знать, какие 
параметры восстанавливать после изменений (для восстановления старых 
параметров),мы будем записывать их в две <i>v</i>-переменных. Я буду использовать переменные v3 и 
v4, соответствуя y3 и y4. Это - причина того, почему я пропустил их ранее.
<script type="erm">!!VRv3&x1=1:Sy3;  [если волшебство усилилось - увеличение силы магии]
!!VRv3&x1=2:S1-y3; [если волшебство ослабилось, установить силу магии на 1]
!!VRv4&x1=1/v6>=0:Sy4;  [если волшебство усилилось, увеличить силу магии]
!!VRv4&x1=2/v6=0:S1-y4; [если волшебство ослабилось, установить силу магии на 1]</script></p>
<p>Новое, что вы заметили здесь в третьей и четвёртой строке - слэш в условиях - то 
же самое, что и логическое &quot;и&quot;. Так, &amp;x1=1/v6&gt;=0 означает &quot;если x1=1 и v6&gt;=0, 
тогда команда работает&quot;.</p>
<p>Теперь мы должны только сделать изменения:
<script type="erm">!!HEv5&x1<>0:Fd0/d0/dv3/d0;  [изменить силу магии]
!!HEv6&x1<>0/v6>=0:Fd0/d0/dv4/d0;  [то же для защищающегося]</script>
Здесь мы изменяем параметры героев, но только если x1 не 0. Помните, что если x1 
= 0, то наш счётчик определяет &quot;нет никаких изменений&quot;.<br>
Снова мы используем команду HE:F. Знак d перед любым числом или переменной 
говорит, что число или переменная должны быть добавлены к параметру.<br>
d0 (d) оставляет параметр без изменений.</p>
<p>Мы теперь завершили до-битвенную функцию!<br>
Теперь наш скрипт таков:
<script type="erm">ZVSE
!#VRv1:S0; [установить v1 на 0]
!?LE0/0/0; [когда посещается событие в северо-западном углу карты]
!!VRv1:+1; [добавить 1 к v1]
!!VRy1:Sv1 %10;  [записать остаток от деления v1 на 10 в y1]
!!IF&y1<>0:M^Вы %V1 посетитель этого северо-западного угла поверхности!^;  [показать сообщение, если более ничего не происходит]
!!VRy2:Sv1 :10 %3;  [найти тип изменения]
!!VRz-1&y2=0:S^сила магии в мире увеличилась!^; [для визита 30, 60, 90, ...]
!!VRz-1&y2=1:S^сила магии в мире ослабевает!^; [для визита 10, 40, 70, ...]
!!VRz-1&y2=2:S^магия в мире стабилизируется!^;  [для визита 20, 50, 80, ...]
!!IF&y1=0:M^Вы %V1 посетитель, вы чувствуете, что %Z-1.^;   [показать измененное сообщение]

;** эффект скрипта в битве

!?BA0;
!!BA:E?y1; [это сетевая битва?]
!!FU1&y1=0:Pv1;  [если нет, продолжить скрипт]

;** за миг до битвы

!?FU1;
!!BA:H0/?v5;  [получить номер героя - атакующего]
!!BA:H1/?v6;  [получить номер героя-защитника]
!!VRx1::10 %3;  [получить тип изменения]
!!HEv5:F?y5/?y6/?y3/?y7;  [получить параметры атакующего]
!!HEv6&y2>0:F?y5/?y6/?y4/?y7;  [получить параметры защитника]
!!VRv3&x1=1:Sy3;  [если магия усилилась, увеличить силу магии]
!!VRv3&x1=2:S1-y3;  [если магия ослабла, уменьшить силу магии до 1]
!!VRv4&x1=1/v6>=0:Sy4; [Если магия усилилась, увеличить силу магии]
!!VRv4&x1=2/v6>=0:S1-y4;  [если магия ослабла, уменьшить силу магии до 1]
!!HEv5&x1<>0:Fd0/d0/dv3/d0;  [изменить силу магии]
!!HEv6&x1<>0/v6>=0:Fd0/d0/dv4/d0;  [то же для защищающегося]</script>
Заметьте, как комментарии помогают пониманию происходящего.</p>
<p>Теперь, после битвы, мы должны вернуть изменения обратно. Сначала мы делаем 
триггер конца битвы:
<script type="erm">;** пост-триггер битвы
!?BA1;
!!BA:E?y1;  [сетевая битва?]
!!FU2&y1=0:Pv1;  [если нет - уничтожить изменения]</script></p>
<p>Выглядит схоже, да? Хорошо, изменения находятся в триггере и номере функции. 
Триггер теперь BA1, это означает, что триггер сработает в конце битвы.<br>
И, так как нам нужно вернуть изменения обратно, нам нужна отдельная функция. К 
счастью, мы сохранили номер героев и изменений в <i>v</i>-переменных, так что нам не 
нужно снова вычислять их.<br>
Давайте начнём уборку:
<script type="erm">!?FU2;
!!VRx1::10 %3;  [получить тип изменений]
!!VRv3:*-1;  [перевернем параметр нападавшего]
!!VRv4:*-1; [перевернем параметр защищающегося]</script></p>
<p>Чтобы v3 и v4 изменились, мы умножили их на -1. Теперь, если мы добавим их, как 
мы сделали прежде, то это уничтожит наши изменения.
<script type="erm">!!HEv5&x1<>0:Fd0/d0/dv3/d0;  [восстановить силу атакующего]
!!HEv6&x1<>0/v6>=0:Fd0/d0/dv4/d0;  [восстановить силу защищающегося]</script>
Опять же имеется проверка на изменение и существование героя-защитника.<br>
Мы должны были хранить числа героев, потому что если герой убежал с поля битвы, 
мы бы уже не смогли найти его параметры.<br>
Наш скрипт готов!</p>
	
<h2><a name="3"></a>Как создать свой первый скрипт #3<br>ERM для чайников, <b id="N1">Qurqirish Dragon</b></h2>
<p>До сих пор скрипт, который мы спроектировали, активизирует герой, когда посещает 
северо-западный угол карты. Зачем бы кто-то отправлял туда героя?</p>
<p>Конечно, вы могли бы всегда помещать событие на карту, уведомляя об этом игрока, но я не 
стану следовать этим путём. Вместо этого, я собираюсь создать нечто, что 
привлечёт игрока. Когда вы зайдёте в редактор карт, посмотрите на страницу 
городов&hellip;<br>
Если вы не заглядывали сюда прежде, то увидите, что здесь много объектов после 
этих 10-ти (9 типов и случайный) городов.<br>
Большинство этих объектов незаскриптованно, т.е. даже если вы поместите их на 
карту, они ничего не будут делать, даже при WoG'ификации на старте.<br>
Мы используем один из них.
<img src="../Img/penta.jpg" width="208" height="177" align="right"></p>
<p>Для этого скрипта я собираюсь использовать <a target="form" href="../form/NewObj.htm#penta">4ый объект</a> из новых объектов WoG.<br>
Поместите это на карту максимально близко к углу, не отрезая никакого 
изображения. Если вы этого обычно не делали, включите инструмент &quot;проходимость&quot; 
- <span class="key">Ctrl</span>+<span class="key">P</span> - разбивку карты на красные и жёлтые площади. Любой красный квадрат 
герой не может посетить или пройти сквозь него. Любой жёлтый квадрат - это 
квадрат выполнения триггера объекта.<br>
Вот что мы видим в редакторе&hellip;<br>
Как я вижу, жёлтый квадрат располагается в координатах [2,2,0].</p>
<p>Теперь давайте изменять скрипт, чтобы использовать этот объект вместо события, 
помещённого ранее. Если вы сделали эту часть обучения, вы можете удалить событие 
- я не буду снова использвать его.</p>
<p>Теперь мы собираемся заменить строку !?LE, чтобы подогнать наш скрипт к 
жёлтому квадрату. Помните, старая строка была:
<script type="erm">!?LE0/0/0; [когда событие в северо-западном углу поверхности посещено]</script>
Теперь мы просто изменяем местоположение на координаты жёлтого квадрата [2,2,0] и меняем триггер LE на OB:
<script type="erm">!?OB2/2/0;  [когда объект в [2,2,0] посещён]</script>
<br>
Заметьте, что фактически триггер OB похож на триггер LE. Если вы не имели 
никаких проблем с LE, значит у вас не будет проблем и с OB.</p>
<p>Только помните, что LE поддерживает только события, а OB поддерживает любые 
объекты, и вы будете знать, когда и какой нужен триггер.<br>
Теперь скрипт будет работать так же, как и прежде, кроме точки запуска. Но я 
собираюсь сделать ещё одно изменение строки:
<script type="erm">!$OB2/2/0;  [ПОСЛЕ того, как объект [2,2,0] посещён]</script></p>
<p>Я изменил эту строку из триггера посещения (!?) на пост-посещение (!$). 
Сейчас это не имеет никаких последствий для скрипта, но теперь скрипт сработает 
после того, что мы ещё добавим: мы сделаем дополнительную возможность, что когда 
вы посетите магический счётчик, за 100 золота вы сможете получить сразу пять 
посещений вместо одного.<br>
Далее есть смысл заменить пентаграмму на Звёздную Ось.<br>
Это только мой выбор, если хотите, заменяйте на какой-либо другой объект, 
имеющий свою функцию. Только убедитесь, что помещённый объект имеет лишь одну 
точку входа, и этот вход расположен в [2,2,0].</p>
<p>Если вы теперь запустите карту, то когда вы посещаете эту Звёздную ось (и только 
ЭТУ!), вы получите, как обычно, +1 к силе магии (или ничего, если ваш герой уже 
посетил ось ранее), и затем счётчик увеличится.</p>
<p>Теперь давайте поместим существо &quot;Магический Сторож&quot; где-либо возле Звёздной 
Оси. Я думаю, что из-за природы скрипта нам подойдет Сказочный дракон.</p>
<p>Так или иначе, давайте начинать скриптинг:
<script type="erm">!?OB2/2/0;  [Когда объект в [2,2,0] посещается]</script>
Это простой триггер пред-посещения.</p>
<p>Теперь мы должны закодировать вопрос да или нет.<br>
Первое, что мы должны понять - мы собираемся задать вопрос, на который нужно 
ответить. Это вызывает проблему, если ИИ посылает героя, чтобы посетить точку.<br>
Так что мы должны посмотреть, является ли текущий игрок человеком или ИИ. Мы 
делаем эту операцию <a href="../Rec/OW.htm">ресивером OW</a>, который позволяет нам проверять или устанавливать 
почти все параметры игрока (но не героя).<br>
Итак, пишем:
<script type="erm">!!OW:C?y1;  [Получить цвет текущего игрока]
!!OW:Iy1/?y2;  [текущий игрок - ИИ?]</script>
Опция C? проверяет цвет текущего игрока. Вы не можете изменить текущего игрока, 
так что знак ? - это часть кода.<br>
Я записываю этот цвет в y1. Следующей строкой я использую опцию I. Эта команда 
проверяет цвет на управляющего: человек это или игрок ИИ. Первое число - это 
цвет игрока для проверки, в нашем случае - y1. Второе число - значение: 1, если 
ИИ, или 0, если человек.<br>
Вы можете установить этот параметр, чтобы добавить или удалить игрока-человека с 
карты! Но сейчас мы хотим лишь узнать это значение. Если это герой ИИ, то y2 
получит значение 1, иначе - 0.</p>
<p>Теперь мы можем задать вопрос.<br>
Так как мы должны показать вопрос, нам понадобится ресивер IF:
<script type="erm">!!IF&y2=0:Q1/6/0/21/134/33/0/2^Вы замечаете Магического сторожа около Звёздной Оси.
Сказочный Дракон подзывает вас:
- Позабавьтесь с магией! За сто золотых счётчик магии прыгнет на целых пять посещений!
Вы согласны?^;</script>
Как вы видите, здесь я добавил условие y2=0. Если ИИ посетит ось, то вопрос не 
будет задаваться!<br>
В любом случае, в этой команде много чисел, не так ли? Их восемь. Я собираюсь 
разобрать их ниже по частям.<br>
Зайдите в описание команды !!IF и найдите опцию 
<b id="erm"><a href="../Rec/IF.htm#Q"><font class="re">!!IF</font>:Q</a>#1/#2/#3/#4/#5/#6/#7/#8<font class="st">^текст^</font>;</b> для точной информации.</p>
<p>Сначала опция Q. Это стандартный вопрос. Дальше - число 1. Это флаг, в который 
занесётся ваш ответ. Флаги похожи на переменные, но могут принимать только два 
значения: 0 (ложь) и 1 (истина). В отличие от переменных, здесь нет указателя 
переменной. Например, <i>v</i>-переменная 1 пишется как &quot;v1&quot;, <i>z</i>-переменная 1 как &quot;z1&quot;, 
а флаг 1 просто 1. Я ещё вернусь к этому моменту позднее.</p>
<p>Следующие шесть чисел добавляют картинки к диалогу под написанным текстом. 
Каждая пара чисел обозначает одну картинку. Первое число - тип картинки, а 
второе число - подтип. Все возможные картинки для использования в диалогах можно найти на 
странице <a href="../Rec/IF.htm">ресивера !!IF</a>.<br>
В этом случае мы описали первое изображение как 6/0. Тип 6 - это ресурс, золото. 
Подтип для ресурса - это его кол-во, которое будет показано.<br>
Так как я установил подтип 0, то кол-во не будет отображаться - просто картинка.<br>
Второе изображение - 21/134. Тип 21 - это монстр, подтип - <a target="form" href="../form/Creature.htm">номер монстра</a>. В данном случае подтип 134 - это Сказочный дракон.<br>
Третье изображение - это 33/0. Тип 33 это один из первичных навыков, в данном 
случае - колдовская сила. Опять же подтип ставим 0, то есть без какого-либо 
кол-ва.<br>
Когда скрипт будет запущен, под текстом будут изображения золота, Сказочного 
Дракона и Колдовской силы.</p>
<p>Последнее число 2 говорит о том, что эта команда - вопрос да или нет. Когда 
скрипт запустится, внизу картинок будут привычные кнопки &lt;Да&gt; или &lt;Нет&gt;. Если вы 
выберете &laquo;Да&raquo;, флаг флаг установится на &quot;Истина&quot; (1), если вы выбрали &laquo;Нет&raquo;, 
флаг установится на &quot;Ложь&quot; (0).</p>
<p>Теперь мы должны проверить, имеет ли игрок 100 золота для оплаты. Используем 
ресивер !!OW. Вот код следующей строки:
<script type="erm">!!OW:R-1/6/?y3;  [узнать, сколько золота имеет текущий игрок]</script>
Опция R означает, что мы хотим сделать что-либо с ресурсами игрока. Первое число 
- цвет игрока, у которого мы будем менять ресурсы. Это значение не-побитно, т.е. 
0 для красного, 1 для синего, и так далее. Также можете посмотреть цвета в 
разделе помощи, но все они пронумерованы от 0 до 7 в порядке том же, что и в 
игре.<br>
Для этого скрипта я устанавливаю игрока -1. Это значит, что мы узнаем опции 
текущего игрока, кто бы это ни был.<br>
Мы уже проверили цвет текущего игрока выше (он сохранен в y1, если вы забыли), 
но я хотел использовать именно -1, чтобы показать эту возможность.<br>
Вы должны проверить синтаксис для каждой опции, чтобы узнать, может ли -1 
использоваться для текущего игрока. Хотя это может обратиться к нейтральному 
игроку, т.е. никому.<br>
Число 6 - номер ресурса, здесь - золото. Последнее число - переменная, в которую 
мы хотим записать кол-во.<br>
В этом случае мы используем переменную y3, и перед ней ставим знак ? , что 
означает &quot;Записать значение в эту переменную&quot;.</p>
<p>Затем мы проверяем, что ответил игрок, и может ли он позволить себе покупку. Мы 
покажем соответствующий ответ для каждого случая. Для этого используем 3 команды 
IF - первая, если нажата кнопка &lt;Нет&gt;, ещё одна для &lt;Да&gt; и если игрок может 
позволить себе покупку, и последняя, если &quot;Да&quot; и игрок не может позволить себе 
покупку:
<script type="erm">!!IF&y2=0/-1:M^Дракон разочарованно поворачивается к другому потенциальному клиенту.^;
!!IF&y2=0/1/y3>=100:M^"Отлично! Я знал, что вам понравится предложение!"^;
!!IF&y2=0/1/y3<100:M^"Я рад, что вы заинтересовались, но у вас недостаточно золота для покупки.
Возвращайтесь позднее!"^;</script></p>
<p>Здесь условие &quot;Это именно человеческий игрок&quot; находится во всех трех командах. 
Второе условие проверяет флаг 1, который устанавливается в зависимости от ответа 
игрока<br>
В первой строке номер флага отрицателен. Это означает, что мы делаем условие &quot;Если 
флаг - Ложь, то проверка пройдена&quot;. В двух других строках флаг положителен, что 
означает &quot;Если флаг - Истина, то проверка пройдена&quot;.<br>
Ещё во второй и третьей строке есть проверка на кол-во золота &quot;Значение 
больше или меньше?&quot;. Прежде чем вычесть 100 золота у игрока, мы должны решить, 
что сделает ИИ.<br>
Позвольте ИИ тоже купить пять посещений - 50%-ый шанс, что он сделает это. Мы 
сделаем это двумя командами:
<script type="erm">!!VRy4:S0 R1;  [генерируем значение от 0 до 1 включительно]
!!IF&y2=1:V1/y4;  [установить флаг в y4]</script></p>
<p>Здесь вы признаете первую строку, но с новой опцией, которую мы прежде не 
использовали - R. Опция R генерирует случайное значение между 0 и числом после R 
(в нашем случае 1), и добавляет его к старому значению. Данный ресивер VR 
устанавливает y4 на 0, и затем добавляет 0 или 1.<br>
Это и является нашим генерируемым шансом.<br>
Следующая строка - наш старый знакомый, ресивер IF. На этот раз условие состоит 
в том, что ходит игрок-ИИ. Опция V используется для установки значения флага. В 
данном случае, флаг 1 устанавливается на результат генерации.</p>
<p>Теперь, когда мы сделали все возможные пути, мы кодируем вычитание золота 
командой OW.
<script type="erm">!!OW&1/y3>=100:R-1/6/d-100;  [вычесть 100 золота, если всё правильно: игрок согласился, золота хватает]</script></p>
<p>Эти два условия должны быть ясны, но мы всё равно резюмируем: первое условие для 
флага, т.е. если он Истина, независимо от того, был ли это сгенерированный флаг 
или сам игрок выбрал его.<br>
Второе условие - проверка, достаточно ли золота у игрока. Как и с колдовской 
силой, мы используем оператор d для вычитания 100 от текущего значения золота<br>
(ну, фактически мы добавляем -100).</p>
<p>Мы должны сделать ещё несколько строк - сейчас, например, добавление счётчика 
при оплате. Так как мы не использовали v2, я сделаю это здесь:
<script type="erm">!!VRv2:S0;  [установить v2 на 0]
!!VRv2&1/y3>=100:+4;  [установить v2 на 4 если оплата была произведена]</script></p>
<p>Заметьте, что хотя золото игрока и изменилось, y3 всё ещё содержит значение 
золота до оплаты. Таким образом, та же самая проверка, которую мы делали в 
команде OW, будет работать и здесь.<br>
Эта часть кода теперь сделана. Но мы ещё должны изменить часть кода, который мы 
уже написали, так как мы должны добавить эти четыре посещения и получить 
соответствующее сообщение.</p>
<p>Вспомните следующие строки из начала скрипта:
<script type="erm">!!VRv1:+1;  [Добавить 1 к v1]
!!VRy1:Sv1 %10;  [найти остаток от деления v1 на 10 в y1]</script></p>
<p>В этой части скрипта y1 - значение счётчика посещений. Для начала мы изменим 
первую строку:
<script type="erm">!!VRv1:+1 +v2;  [добавить 1+v2 к v1]</script></p>
<p>Если оплата была произведена, то это добавит 5 к v1, иначе - только 1.<br>
Далее добавим строку после вычисления y1:
<script type="erm">!!VRy1&y1<=v2:S0;  [сброс y1, если число уже не кратно 10]</script></p>
<p>Если дополнительные пять посещений перескочили через число, кратное десяти, то 
означает, что v2 была равна 4, таким образом y1 между 1 и 4.<br>
Так, если y1 меньше или равен v2, это означает, что магический статус должен 
сработать - таким образом мы устанавливаем y1 на 0.<br>
Оставшаяся часть кода может оставаться без изменений!</p>
<p>Теперь, после небольших изменений скрипт выглядит так:
<script type="erm">ZVSE
!#VRv1:S0;  [установить v1 на 0]

;** триггер пост-посещения
!$OB2/2/0;  [ПОСЛЕ посещения объекта в [2,2,0]]
!!VRv1:+1 +v2;  [добавить 1+v2 к v1]
!!VRy1:Sv1 %10;  [найти остаток от деления v1 на 10 в y1]
!!VRy1&y1<=v2:S0;  [сброс y1, если число уже не кратно 10]
!!IF&y1<>0:M^Добро пожаловать на Звёздную ось. Магический счётчик показывает 
значение %V1^;  [Показать сообщение, если ничего не произошло]
!!VRy2:Sv1 :10 %3;  [найти тип изменения магии]
!!VRz-1&y2=0:S^сила магии в мире увеличилась!^;  [для визита 30, 60, 90, ...]
!!VRz-1&y2=1:S^сила магии в мире ослабевает!^;  [для визита 10, 40, 70, ...]
!!VRz-1&y2=2:S^магия в мире стабилизируется!^;  [для визита 20, 50, 80, ...]
!!IF&y1=0:M^Магический счётчик теперь равен %V1... Вы чувствуете, что %Z-1.^;  [показать измененное сообщение]

;** эффект скрипта в битве
!?BA0;
!!BA:E?y1;  [это сетевая битва?]
!!FU1&y1=0:Pv1;  [если нет, запускаем скрипт]

;** за миг до битвы
!?FU1;
!!BA:H0/?v5;  [получить номер героя - атакующего]
!!BA:H1/?v6;  [получить номер героя - защитника]
!!VRx1::10%3;  [получить тип изменения магии]
!!HEv5:F?y5/?y6/?y3/?y7;  [получить параметры атакующего]
!!HEv6&v6>0:F?y5/?y6/?y4/?y7;  [получить параметры защищающегося]
!!VRv3&x1=1:Sy3;  [если магия усилена, увеличить значение]
!!VRv3&x1=2:S1-y3;  [если магия ослаблена, установить на 1]
!!VRv4&x1=1/v6>=0:Sy4;  [если магия усилена, увеличить значение]
!!VRv4&x1=2/v6>=0:S1-y4; [если магия ослаблена, установить на 1]
!!HEv5&x1<>0:Fd0/d0/dv3/d0;  [изменить силу магии]
!!HEv6&x1<>0/v6>=0:Fd0/d0/dv4/d0;  [то же для защитника]

;** пост-битвенный триггер
!?BA1;
!!BA:E?y1;  [это сетевая битва?]
!!FU2&y1=0:Pv1;  [если нет, продолжить]

!?FU2;
!!VRx1::10 %3;  [получить тип изменений]
!!VRv3:*-1;  [изменим параметр атакующего на отрицательный]
!!VRv4:*-1;  [изменим параметр защищающегося на отрицательный]
!!HEv5&x1<>0:Fd0/d0/dv3/d0;  [восстановим силу атакующего]
!!HEv6&x1<>0/v6>=0:Fd0/d0/dv4/d0;  [восстановим силу защищающегося]

;** триггер посещения объекта
!?OB</font></a>2/2/0;  [объект [2,2,0] посещён]
!!OW:C?y1;  [получить текущий цвет]
!!OW:Iy1/?y2;  [текущий игрок - ИИ?]
!!IF&y2=0:Q1/6/0/21/134/33/0/2^Вы замечаете Магического сторожа около Звёздной Оси.
Сказочный Дракон подзывает вас:
- Позабавьтесь с магией! За сто золотых счётчик магии прыгнет на целых пять посещений!
Вы согласны?^;
!!OW:R-1/6/?y3;  [Найти кол-во золота игрока]
!!IF&y2=0/-1:M^Дракон разочарованно поворачивается к другому потенциальному клиенту.^;
!!IF&y2=0/1/y3>=100:M^&quot;Отлично! Я знал, что вам понравится предложение!&quot;^;
!!IF&y2=0/1/y3<100:M^"Я рад, что вы заинтересовались, но у вас недостаточно золота для покупки.
Возвращайтесь позднее!"^;
!!VRy4:S0 R1;  [генерируем значение]
!!IF&y2=1:V1/y4;  [устанавливаем флаг в значение]
!!OW&1/y3>=100:R-1/6/d-100;  [забираем 100 золота, если согласны]
!!VRv2:S0;  [устанавливаем v2 на 0]
!!VRv2&1/y3>=100:+4;  [устанавливаем v2 на 4, если плата произведена]</script></p>

<h2><a name="4"></a>Как создать свой первый скрипт #4<br>ERM для чайников, <b id="N1">Qurqirish Dragon</b></h2>
<p>Я ввёл множество команд в последнем скрипте. Как вы можете видеть в справке, 
многие команды имеют куда больше опций, чем мы использовали. Я хочу более 
детально разобрать некоторые.<br>
По скрипту, первая команда - VR.<br>
Синтаксис начала строки<br>
<a href="../Rec/VR.htm">!!VR</a>@:XXXX<br>
Где бы вы не увидели в помощи @ - это </p>

<h2><a name="Stone"></a>Создание магического поющего камня<br><b id="N1">Fnord the Wizard</b></h2>
<p>В этом примере мы сделаем волшебный поющий камень, который может быть 
посещён героем. Камень даст герою маны в кол-ве [Знание&times;40] 
и заберёт все очки хода.</p>
<ol align="left"><li>Используя редактор, выберите камень покрасивее и поместите 
его куда-нибудь на карту. Для наглядности, поместим его в x=10, y=12, уровень=0 
(поверхность).
<li>Создадим глобальное событие, куда вы введете ERM-код. 
Установим день появления на 500 и назовем его &quot;Поющий 
камень&quot;. Начинаться событие будет так:<br><b><code><font color="#0000FF">ZVSE</font></code></b></li>
<li>Используем инструкцию для возможности посещения камня:<br>
<b><code><a href="../Rec/TR.htm"><font color="#808000">!#TR</font></a>10/12/0:P1; </code></b></li>
<li>Также, сделаем инструкцию, чтобы была возможность посещать камень (жёлтый квадрат):<br>
<b><code><a href="../Rec/TR.htm"><font color="#808000">!#TR</font></a>10/12/0:E0;</code></b></li>
<li>Сделаем инструкцию на превращение камня в другой объект (важно!), скажем, колодца:<br>
<b><code><a href="../Rec/OB.htm"><font color="#808000">!#OB</font></a>10/12/0:T49;</code></b></li>
<li>Инструкцией отключим стандартные свойства объекта (колодца):<br>
<b><code><a href="../Rec/OB.htm"><font color="#808000">!#OB</font></a>10/12/0:S;</code></b></li>
<li>Изменим текст-подсказку нового объекта:<br>
<b><code><a href="../Rec/VR.htm"><font color="#808000">!#VR</font></a>z1:S^Поющий камень^; <font class=co>
[присвоить текст переменной z1]</font></code></b><br>
<b><code><a href="../Rec/OB.htm"><font color="#808000">!#OB</font></a>10/12/0:H1; <font class=co>
[установить текст-подсказку из z1]</font></code></b></li>
<li>Используем триггер на посещение нашего объекта:<br>
<b><code><a href="../Tr/OB.htm"><font class=tr>!?OB</font></a>10/12/0;</code></b></li>
<li>Покажем сообщение:<br>
<b><code><a href="../Rec/IF.htm"><font color="#800080">
!!IF</font></a>:M^Камень призывает вас отдохнуть своей приятной магической мелодией.^;</code></b></li>
<li>Установим ману героя:<br>
<b><code><a href="../Rec/HE.htm"><font color="#800080">!!HE</font></a>-1:Fd0/d0/d0/?v1; <font class=co>
[запишем знания в v1]</font></code></b><br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>v1:*40; <font class=co>
[умножим v1 на 40]</font></code></b><br>
<b><code><a href="../Rec/HE.htm"><font color="#800080">!!HE</font></a>-1:Iv1; <font class=co>
[установим кол-во маны на v1]</font></code></b><br>
<b><code><a href="../Rec/IF.htm"><font color="#800080">!!IF</font></a>:Q1/35/v1/1^^; <font class=co>
[покажем картинку бонуса маны]</font></code></b></li>
<li>Заберём очки хода:<br>
<b><code><a href="../Rec/HE.htm"><font color="#800080">!!HE</font></a>-1:W0;</code></b></li>
Готово! :-)</ol>
<p>Если пропустить шаги 5 и 6, курсор всё ещё будет превращаться в лошадь на дыбах 
(как на обычный жёлтый квадрат), но когда вы зайдете героем&nbsp; квадрат, 
ничего не произойдет, *пока* вы не нажмёте пробел для повторного посещения. Это 
допустимо для некой загадки, но для нового объекта, который должен работать как 
и все другие, вы должны включить шаги 5 и 6. Это действительно при любом 
превращении непосещаемого по умолчанию объекта в помещаемый.</p>
<p>Полный код:
<script type="erm">ZVSE
!#TR10/12/0:P1;
!#TR10/12/0:E0;
!#OB10/12/0:T49;
!#OB10/12/0:S;
!#VRz1:S^Поющий камень^;
!#OB10/12/0:H1;
!?OB10/12/0;
!!IF:M^Камень призывает вас отдохнуть своей приятной магической мелодией.^;
!!HE-1:Fd0/d0/d0/?v1;
!!VRv1:*40;
!!HE-1:Iv1;
!!IF:Q1/35/v1/1^^;
!!HE-1:W0;</script></p>

<h2><a name="8"></a>Помещение жилищ 8го уровня<br><b id="N1">Anders</b></h2>
<p>В этом примере мы поместим жилище 8го уровня в выбранном месте. Жилище будет 
привязано к выбранному городу.<br>
Сначала, поместим на карте замок (желательно случайный), в x=2,
y=4, z=0 (поверхность).<br>
Затем, создайте глобальное событие, установите дату на 500 день, дайте имя &quot;8ой 
уровень&quot;, ну или какое хотите, и напишите стандартную первую строку
<font color="#0000FF"><b><code>ZVSE</code></b></font>.<br>
<i id="bold">Замечание:</i> скрипт будет полностью состоять из инструкций, жилище появится 
на карте ещё во время загрузки оной.<br>
Теперь, проверим, какой тип города получился (все города имеют одинаковый тип 
объекта, но разные подтипы: Замок = 0, Инферно = 4) и запишем значение в 
переменную v1:<br>
<b><code><a href="../Rec/OB.htm"><font color="#808000">!#OB</font></a>2/4/0:U?v1;</code></b><br>
Теперь добавим 80 к числу для получения корректного
<a target="form" href="../Form/CreatureDwellings.htm">номера жилища</a>:<br>
<b><code><a href="../Rec/VR.htm"><font color="#808000">!#VR</font></a>v1:+80;<br>
</code></b>(Вы могли бы сделать список для записи числа в зависимости от типа города, вроде:<br>
<b><code><a href="../Rec/VR.htm"><font color="#808000">!#VR</font></a>v1&amp;v1=0:S80;</code></b><br>
<b><code><a href="../Rec/VR.htm"><font color="#808000">!#VR</font></a>v1&amp;v1=1:S81;</code></b><br>
<b><code>&hellip;</code></b><br>
<b><code><a href="../Rec/VR.htm"><font color="#808000">!#VR</font></a>v1&amp;v1=8:S88;<br>
</code></b>&hellip; но это длиннее и не влияет на итоговый результат)<br>
Теперь, определим, где поставить жилище. Запишите точку в переменные, потому что 
разные жилища имеют разный размер - вы можете увидеть это в редакторе. В данном 
примере, запишите X=27 в v2, Y=3 в v3 и Уровень (0 = поверхность) в v4</span>:<br>
<b><code><a href="../Rec/VR.htm"><font color="#808000">!#VR</font></a>v2:S27;<br>
<a href="../Rec/VR.htm"><font color="#808000">!#VR</font></a>v3:S3;<br>
<a href="../Rec/VR.htm"><font color="#808000">!#VR</font></a>v4:S0;<br>
</code></b>Теперь вы должны упредить разницу в размере жилищ. Если это НЕ жилище 
Громовержцев (Башня) или Антихристов (Инферно), оно должно быть помещено на 1 
клетку правее для точного попадания на точку:<br>
<b><code><a href="../Rec/VR.htm"><font color="#808000">!#VR</font></a>v2&amp;v1&lt;&gt;82/v1&lt;&gt;83:+1;</code></b><br>
Теперь помещаем жилище: <br>
<b><code><a href="../Rec/UN.htm"><font color="#808000">!#UN</font></a>:Iv2/v3/v4/17/v1;</code></b></p>
<p>Полный скрипт:
<script type="erm">ZVSE
!#OB13/20/0:U?v1;
!#VRv1:+80;
!#VRv2:S27;
!#VRv3:S3;
!#VRv4:S0;
!#VRv2&v1<>82/v1<>83:+1;
!#UN:Iv2/v3/v4/17/v1;</script>
Он, конечно, может быть повторен снова и снова, если вы хотите привязать больше 
жилищ к карте. Если вы привязываете более одного жилища к одному городу, вам 
нужно лишь копировать последние 5 строк и поместить их под остальным, и изменить 
координаты появления на нужные. Если вы желаете привязать жилище к другому 
городу, скопируйте всё, кроме ZVSE, и 
измените координаты города и жилища.</p>

<h2><a name="mithril"></a>Показ мифрила при его подборе<br><b id="N1">Anders</b></h2>
<p>Этот скрипт будет показывать диалоговое окно, когда игрок подберёт Мифрил на 
карте, показывая кол-во мифрила в кучке и его общее кол-во у игрока.<br>
Поместите несколько мифриловых кучек на карту, и создайте глобальное событие, 
день срабатывания установите на 500, первая строка - <font color="#0000FF"><b><code>
ZVSE</code></b></font>.<br>
Теперь вам нужно включить кучки мифрила, иначе они будут собираться как золото. 
Сделаем это инструкцией: <br>
<b><code><a href="../Rec/UN.htm"><font color="#808000">!#UN</font></a>:B0/1;</code></b> <br>
Затем, триггер для всех кучек мифрила, но не для других ресурсов:<br>
<b><code><a href="../Tr/OB.htm"><font class=tr>!?OB</font></a>79/7;</code></b><br>
Затем, проверим, кто подобрал мифрил и запомним его имя в z1:<br>
<b><code><a href="../Rec/HE.htm"><font color="#800080">!!HE-1</font></a>:B0/?z1;</code></b><br>
Теперь проверим, сколько мифрила в кучке (триггер срабатывает прямо перед 
подбором и добавлением к общему кол-ву). Сохраним в y1: <br>
<b><code><a href="../Rec/AR.htm"><font color="#800080">!!AR</font></a>v998/v999/v1000:V?y1;</code></b><br>
Теперь, проверим, сколько мифрила имеет игрок до подбора кучки, и добавим 
кол-во в кучке к этому числу: <br>
<b><code><a href="../Rec/OW.htm"><font color="#800080">!!OW</font></a>:R-1/7/?y2;</code></b> 
<font class=co>[записать текущее кол-во мифрила игрока в y2]</font><br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>y2:+y1;</code></b> 
<font class=co>[добавить новый мифрил к имеющемуся в y2]</font> <br>
Теперь добавим корректные сообщения при подборе кучек. Если в ней 1 мифрил, 
пишем &quot;брусок&quot;, если больше 1 но меньше 5 то пишем &quot;бруска&quot;, если больше 4 пишем 
&quot;брусков&quot;. А также подумаем об суммарном кол-ве: если 1, пишем &quot;брусок&quot;, 
если 1&lt;x&lt;5 пишем &quot;бруска&quot;, если 
5&lt;x&lt;21 пишем &quot;брусков&quot;, а дальше используем функцию нахождения остатка от 
деления чисел, и к соответственному значению настраиваем соответствующую форму слова.<br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>y3:Sy2;</code></b> 
<font class=co>присвоим кол-во имеющихся брусков переменной y3</font><br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>y3&amp;y3&gt;20:%10;</code></b> 
<font class=co>если она больше 20, найдём остаток от деления на 10 (получатся числа от 0 до 9)</font><br>
Далее формы для &quot;кучки&quot;:<br>
<a href="../Rec/VR.htm"><font color="#800080"><b><code>!!VR</font></a>z3&amp;y1=1:S^брусок^;<br>
<a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z3&amp;y1&gt;1/y1&lt;5:S^бруска^;<br>
<a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z3&amp;y1&gt;4:S^брусков^;</code></b> <br>
А теперь формы для общего кол-ва<br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z2|y2=1/y3=1:S^брусок^;</code></b> 
<font class=co>используя условие ИЛИ ( <b>|</b> ), устанавливаем фору слова, если число имеющихся 
брусков равно 1 ИЛИ остаток от деления на 10 равен 1</font><br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z2&amp;y2&gt;1/y2&lt;5:S^бруска^;</code></b> 
<font class=co>используем два условия - брусков больше 1 И меньше 5</font><br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z2&amp;y2&gt;4/y2&lt;21:S^брусков^;</code></b> 
<font class=co>используем 2 условия - брусков больше 4 И меньше 21</font><br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z2&amp;y2&gt;20/y3&gt;1/y3&lt;5:S^бруска^;</code></b> 
<font class=co>используем 3 условия - брусков больше 20, остаток от деления меньше 5, но больше 1</font><br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z2&amp;y2&gt;20/y3&gt;4:S^брусков^;</code></b> 
<font class=co>если брусков больше 20 и остаток от деления в пределах 4..9</font><br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z2&amp;y2&gt;20/y3=0:S^брусков^;</code></b> 
<font class=co>если брусков больше 20 и остаток равен 0.</font></p>
<p align="left">Вы можете установить проверку на остаток и для &quot;кучки&quot;, но редко 
встречаются кучки с содержанием мифрила 20+<br>
Теперь осталось лишь вывести сообщение, если текущий игрок не компьютер.<br>
<b><code><a href="../Rec/IF.htm"><font class=re>!!IF</font></a>&amp;1000:Q1/7/y1/1^{Мифрил}<br>
<br>
%Z1 подобрал %Y1 %Z3 волшебного Мифрила.<br><br>
{Всего у вас %Y2 %Z2 Мифрила.}^;</code></b></p>
<p>Полностью скрипт:
<script type="erm">ZVSE
!#UN:B0/1;
!?OB79/7;
!!HE-1:B0/?z1;
!!ARv998/v999/v1000:V?y1;
!!OW:R-1/7/?y2;
!!VRy2:+y1;
!!VRy3:Sy2;
!!VRy3&y3>20:%10;
!!VRz3&y1=1:S^брусок^;
!!VRz3&y1>1/y1<5:S^бруска^;
!!VRz3&y1>4:S^брусков^; 
!!VRz2|y2=1/y3=1:S^брусок^;
!!VRz2&y2>1/y2<5:S^бруска^;
!!VRz2&y2>4/y2<21:S^брусков^;
!!VRz2&y2>20/y3>1/y3<5:S^бруска^;
!!VRz2&y2>20/y3>4:S^брусков^;
!!VRz2&y2>20/y3=0:S^брусков^;
!!IF&1000:Q1/7/y1/1^{Мифрил}

%Z1 подобрал %Y1 %Z3 волшебного Мифрила.

{Всего у вас %Y2 %Z2 Мифрила.}^;</script>

<h2><a name="m_show"></a>Показ мифрила<br><b id="N1">Anders</b></h2>
<p>Этот скрипт будет показывать текущее кол-во мифрила игрока при правом клике 
по кнопка &quot;Просмотр королевства&quot;.<br>
Начнём с создания глобального события с текстом <font color="#0000FF"><b><code>ZVSE</code></b></font>. 
Затем, триггер на правый клик: <br>
<b><code><a href="../Tr/CM.htm"><font class=tr>!?CM;</font></a></code></b> <br>
Теперь узнаем, куда кликнули, и запишем в y1:<br>
<b><code><a href="../Rec/CM.htm"><font color="#800080">!!CM</font></a>:I?y1;</code></b> <br>
И выйдем, если не на кнопку &quot;просмотр королевства&quot;<br>
<b><code><a href="../Rec/FU.htm"><font color="#800080">!!FU</font></a>&amp;y1&lt;&gt;3:E;</code></b><br>
Затем узнаем, кто сейчас ходит и сколько мифрила он имеет:<br>
<b><code><a href="../Rec/OW.htm"><font color="#800080">!!OW</font></a>:C?y3;</code></b> <font class=co>[записать номер ходящего игрока в y3]</font> <br>
<b><code><a href="../Rec/OW.htm"><font color="#800080">!!OW</font></a>:Ry3/7/?y2;</code></b> <font class=co>[сохранить мифрил текущего игрока в y2]</font> <br>
Временная переменная z-1 будет хранить форму слова &quot;брусок&quot; в зависимости от их 
кол-ва.<br>
<b><code>
<a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>y1:Sy2;<br>
<a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>y1&amp;y1&gt;20:%10;</code></b><br>
<b><code>
<a href="../Rec/VR.htm"><font color="#800080">!!VR</a></font>z2|y2=1/y1=1:S^брусок^;<br>
<a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z2&amp;y2&gt;1/y2&lt;5:S^бруска^;</code></b>
<br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z2&amp;y2&gt;4/y2&lt;21:S^брусков^;</code></b><br>
<b><code><a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z2&amp;y2&gt;20/y1&gt;1/y1&lt;5:S^бруска^;<br>
<a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z2&amp;y2&gt;20/y1&gt;4:S^брусков^;<br>
<a href="../Rec/VR.htm"><font color="#800080">!!VR</font></a>z2&amp;y2&gt;20/y1=0:S^брусков^;</code></b><br>
Для деталей смотрите скрипт <a href=#mithril>выше</a>.<br>
Теперь уточним, что кликнул именно текущий игрок (только 
для мультиплеера).<br>
<b><code><a href="../Rec/OW.htm"><font color="#800080">!!OW</font></a>:Gy3/?y4;</code></b> <br>
Теперь, если всё правильно, покажем сообщение:<br>
<b><code><a href="../Rec/IF.htm"><font color="#800080">!!IF</font></a>&amp;y1=3/y3=y4:Q1/7/y2/4^{Мифрил}<br><br>
У вас %Y2 %Z2 мифрила.^; </code></b><br>
Затем остаётся лишь отключить стандартное сообщение правого клика по кнопке 
&quot;просмотр королевства&quot;:<br>
<b><code><a href="../Rec/CM.htm"><font color="#800080">!!CM</font></a>&amp;y1=3/y3=y4:R0;</code></b></p>
<p>Полный скрипт:
<script type="erm">ZVSE
!?CM;
!!CM:I?y1;
!!FU&y1<>3:E;
!!OW:C?y3;
!!OW:Ry3/7/?y2;
!!VRy1:Sy2;
!!VRy1&y1>20:%10;
!!VRz2|y2=1/y1=1:S^брусок^;
!!VRz2&y2>1/y2<5:S^бруска^;
!!VRz2&y2>4/y2<21:S^брусков^;
!!VRz2&y2>20/y1>1/y1<5:S^бруска^;
!!VRz2&y2>20/y1>4:S^брусков^;
!!VRz2&y2>20/y1=0:S^брусков^;
!!OW:Gy3/?y4;
!!IF&y1=3/y3=y4:Q1/7/y2/4^{Мифрил} 

У вас %Y2 %Z2 мифрила.^;
!!CM&y1=3/y3=y4:R0;</script></p>

<h2><a name="exp"></a>Методика создания уникальных способностей для ваших существ<br><b id="N1">Salamandre</b></h2>
<p>Уникальные способности – наиболее привлекательная составляющая WoG. Их изменение делает сценарий более динамичным 
и реиграбельным.<br>
Понятно, что данная тема адресована людям без высоких навыков скриптописания, 
и здесь будут описаны довольно элементарные вещи для любого опытного скриптера.<br>
Необязательно быть <b id="N1">Fnord</b>'ом, чтобы сделать нечто подобное, всё довольно легко исполняется и описывается.</p>
<p>К примеру, заставим Чародеев колдовать Волну Смерти в бою, 
а также дадим им иммунитет к вражеским заклинаниям 1го уровня и Волне Смерти.<br>
Итак, вам нужно открыть <a target="form" href="../Form/SpecExp4.htm">таблицу бонусов опыта существ</a> для 
<a href="../Rec/EA.htm#B">EA:B</a> (при $3=119).</p>
<ol id="T0"><li> Сначала вы должны пояснить игре, что она должна выполнить команды при загрузке карты. 
Это делается с помощью команды <a href="../Tr/PI.htm"><font class="tr">!?PI</font></a>;</li>
<li> Теперь нужно удалить все <a target="form" href="../Form/SpecExp1.htm">способности существ</a>, с которыми они начинают, и 
установить нужные. Очистим таблицу способностей с помощью следующих строк:
(Мы используем Чародеев, их <a target="form" href="../Form/Creature.htm">номер</a> = 136)</li>
<li> Итак, имеем:
<script type="erm">!?PI;
!!EA136:B5/0/////////////;
!!EA136:B6/0/////////////;
!!EA136:B7/0/////////////;
!!EA136:B8/0/////////////;
!!EA136:B9/0/////////////;
!!EA136:B10/0/////////////;
!!EA136:B11/0/////////////;
!!EA136:B12/0/////////////;</script>
Это значит, что Чародеи не будут иметь способностей опыта с первого дня.</li></ol>
<p>Теперь давайте настроим нужное.<br>
Посмотрим на первую пустую линию:
<script type="erm">!!EA136:B5/0/////////////;</script>
Мы должны заполнить пространство между слэшами для корректного показа способности.<br>
Судя по <a target="form" href="../Form/SpecExp4.htm">таблице опыта существ</a>, номер способности &quot;Иммунитет к вражеским 
заклинаниям 1го уровня&quot; = 49.<br>
<b id="erm"><font class="re">!!EA</font>136</b> - необходимое начало команды, которое объясняет, что таблица опыта монстра 136 будет изменяться.<br>
<b id="erm">B5</b> определяет, что это первая линия.<br>
<b id="erm"><font class="re">!!EA</font>136:B5/1</b> означает установку новой способности (1). Ноль означает удаление способности, что мы уже проделали.<br>
Дальнейшие числа относятся к способности и её шансу на срабатывание на разных уровнях опыта. 
Нам нужно указать число <a target="form" href="../Form/SpecExp1.htm">119</a> перед настройкой любой способности из 
таблицы иммунитетов.<br>
<b id="erm"><font class="re">!!EA</font>136:B5/1/119/49..</b> &rarr; иммунитет к вражеским заклинаниям 1го уровня.<br>
Теперь мы должны указать % шанс, но, т.к. это не заклинание, а иммунитет, то мы можем указать лишь 1 (есть) или 0 (нету).<br>
<b id="erm"><font class="re">!!EA</font>136:B5/1/119/49/0/0/0/0/1/1/1/1/1/1/1;</b> - всего 11 уровней опыта<br>
У нас иммунитет будет с 4го уровня (27600)</p>
<p>Теперь о процентах.<br>
Пусть Чародеи будут колдовать заклинание Волна Смерти.<br>
Из <a target="form" href="../Form/SpecExp1.htm">таблицы опыта</a> имеем: колдует заклинание перед атакой = 112. 
Можно также сделать, чтобы оно колдовалось после атаки, выставив соответствующий номер.<br>
В <a target="form" href="../Form/Spell.htm">таблице заклинаний</a> находим знеачение для Волны Смерти &rarr; 24.</p>
<p>Т.к. первая бонусная линия занята иммунитетом, пойдём на вторую (В6): 
<b id="erm"><font class="re">!!EA</font>136:B6/1/112/24..</b><br>
<p>Дальше указываем процентный шанс существа наколдовать заклинание на каждом уровне опыта. 
Вы можете указывать какие захотите процентные значения, хоть 100% на 1-ом уровне. В этом примере будет немного сбалансировано:<br>
<script type="erm">!!EA136:B5/1/112/24/0/0/5/10/15/20/30/35/40/45/50;</script>
Теперь Чародеи имеют 50% шанс наколдовать Волну Смерти на 10 уровне опыта.</p>
<p>Вот что у нас сейчас имеется:
<script type="erm">ZVSE
!?PI
!!EA136:B5/0/////////////;
!!EA136:B6/0/////////////;
!!EA136:B7/0/////////////;
!!EA136:B8/0/////////////;
!!EA136:B9/0/////////////;
!!EA136:B10/0/////////////;
!!EA136:B11/0/////////////;
!!EA136:B12/0/////////////;
!!EA136:B5/1/119/49/0/0/0/0/1/1/1/1/1/1/1; иммунитет ко вражеским заклинаниям 1го уровня
!!EA136:B5/1/112/24/0/0/5/10/15/20/30/35/40/45/50; колдует волну смерти перед атакой</script></p>
<p>Продолжим добавлять способности.<br>
Теперь добавим иммунитет ко всем вражеским заклинаниям. Код, в принципе, останется таким же, за исключением чисел.<br>
Т.к. полный иммунитет к магии (<a target="form" href="../Form/SpecExp4.htm">53</a>) это не шутка, нельзя давать его так же рано, как к 1-ому уровню.<br>
Настроим третью строку: <b id="erm"><font class="re">!!EA</font>136:B7</b><br>
Сделаем способность доступной с 10 уровня (105000 опыта)<br>
Код:
<script type="erm">!!EA136:B7/1/119/53/0/0/0/0/0/0/0/0/0/0/1;</script>
<p>Иммунитет будет доступен только при достижении максимального уровня опыта.
<br>
Теперь сделать иммунитет к заклинаниям с помощью опыта сможет любой, умеющий 
читать.</p>
<p>А теперь обратимся к другой таблице. Процентный шанс здесь работает как 
нужно, поэтому настройка здесь более тонкая. Вы не должны давать существу с 
полным иммунитетом к магии 100% шанс блока, только если не хотите помучить 
тестеров вашей карты.</p>
<p>Настроим блок Чародеям, поработаем с четвёртой линией: <b id="erm"><font class="re">!!EA</font>136:B8</b></p>
<p>В <a target="form" href="../Form/SpecExp1.htm">таблице</a> Блок - это номер 66. 
Также мы напишем 61 (<a target="form" href="../Form/SpecExp5.htm">установить</a>) на 4ой позиции: B8/1/66/61</p>
<script type="erm">!!EA136:B8/1/66/61/0/5/10/15/25/35/40/50/55/60/65;</script>
<p>Теперь Чародеи имеют потрясающий шанс заблокировать атаку врага на уровне Ас. 
Более половины атак будут неудачны. Осторожно, т.к. бой с такими монстрами может быть фатальным ;)</p>
<p>Чародеи всё ещё довольно слабы по здоровью, не так ли? Так пусть они вызывают 
Клон (<a target="form" href="../Form/SpecExp1.htm">108</a>).</p>
<p>Но, нам нужно определить, какое <a target="form" href="../Form/Creature.htm">существо</a> они будут вызывать: они даже могут 
вызывать Лазурных драконов. Я бы установил на вызов тех же Чародеев (номер 136).</p>
<script type="erm">!!EA136:B9/1/108/136/10/20/25/30/40/50/70/75/80/85/90;</script>
<p>Процент в примере очень велик: на последнем уровне Чародеи будут вызывать 90% самих себя. 
Используйте меньшие числа, чтобы не поломать баланс игры.</p>
<p>Наложить заклинание на существо.</p>
<p>Мы будем накладывать Молитву. По <a target="form" href="../Form/SpecExp1.htm">таблице</a>, &quot;очаровывает заклинанием&quot; = 115. 
Мы должны настроить заклинание, взяв номер из <a target="form" href="../Form/Spell.htm">таблицы заклинаний</a>.</p>
<p>Молитва - 48, имеем: <b id="erm"><font class="re">!!EA</font>136:B10/1/115/48</b></p>
<p>В качестве параметров для каждого уровня опыта в случае заклинания мы указываем уровень магии.</p>
<pre>0 = ещё не активировано
1 = базовый
2 = продвинутый
3 = эксперт</pre>
<script type="erm">!!EA136:B10/1/115/48/0/0/1/1/1/2/2/2/3/3/3;</script>
<p>В итоге:
<script type="erm">ZVSE
!?PI;
!!EA136:B5/0/////////////;
!!EA136:B6/0/////////////;
!!EA136:B7/0/////////////;
!!EA136:B8/0/////////////;
!!EA136:B9/0/////////////;
!!EA136:B10/0/////////////;
!!EA136:B11/0/////////////;
!!EA136:B12/0/////////////;

!!EA136:B5/1/119/49/0/0/0/0/1/1/1/1/1/1/1; иммунитет к вражеским заклинаниям 1го уровня
!!EA136:B6/1/112/24/0/0/5/10/15/20/30/35/40/45/50; колдует Волну Смерти перед Атакой
!!EA136:B7/1/119/53/0/0/0/0/0/0/0/0/0/0/1; иммунитет ко вражеским заклинаниям
!!EA136:B8/1/66/61/0/5/10/15/25/35/40/50/55/60/65; Блок
!!EA136:B9/1/108/136/10/20/25/30/40/50/70/75/80/85/90; вызывает Клон каждый раунд
!!EA136:B10/1/115/48/0/0/1/1/1/2/2/2/3/3/3; зачарован Молитвой</script></p>
<p>И, наконец, <a target="form" href="../Form/SpecExp2.htm">флаговые</a> способности</p>
<p>Они тоже довольно полезны, и мы установим две из них, чтобы завершить нашу &laquo;машину смерти&raquo;: Двойная атака и Безответный удар.</p>
<p>Из-за новой таблицы, третий параметр - <a target="form" href="../Form/SpecExp1.htm">102</a>, а сама способной будет четвёртой.</p>
<p>Двойной удар (68) настраивается как и иммунитеты (0 = способность недоступна, 1 = активирована).</p>
<script type="erm">!!EA136:B11/1/102/68/0/0/0/0/1/1/1/1/1/1/1;</script>
<p>В зависимости от времени активации способности, вы можете сразу сотворить 
стреляющих дуплетом чародеев для уничтожения всего и вся, или всё же дать эту 
способность только на последнем уровне опыта.</p>
<p>Принцип для &quot;Безответный&quot; такой же (82)</p>
<script type="erm">!!EA136:B12/1/102/82/0/0/0/0/0/1/1/1/1/1/1;</script>
<p>В общем и целом, наш итоговый код будет таким:
<script type="erm">ZVSE
!?PI;
!!EA136:B5/0/////////////;
!!EA136:B6/0/////////////;
!!EA136:B7/0/////////////;
!!EA136:B8/0/////////////;
!!EA136:B9/0/////////////;
!!EA136:B10/0/////////////;
!!EA136:B11/0/////////////;
!!EA136:B12/0/////////////;

!!EA136:B5/1/119/49/0/0/0/0/1/1/1/1/1/1/1; иммунитет к вражеским заклинаниям 1го уровня
!!EA136:B6/1/112/24/0/0/5/10/15/20/30/35/40/45/50; колдует Волну Смерти перед Атакой
!!EA136:B7/1/119/53/0/0/0/0/0/0/0/0/0/0/1; иммунитет ко вражеским заклинаниям
!!EA136:B8/1/66/61/0/5/10/15/25/35/40/50/55/60/65; Блок
!!EA136:B9/1/108/136/10/20/25/30/40/50/70/75/80/85/90; вызывает клон каждый раунд
!!EA136:B10/1/115/48/0/0/1/1/1/2/2/2/3/3/3; зачарован Молитвой
!!EA136:B11/1/102/68/0/0/0/0/1/1/1/1/1/1/1; двойная атака
!!EA136:B12/1/102/82/0/0/0/0/0/1/1/1/1/1/1; безответный</script></p>
<p>
<img src="../Img/train.jpg" width="795" height="574"><br>
Самое главное, что вы можете давать эти способности после срабатывания какого-либо триггера, вместе с сообщением.</p>
<p>Например:
<script type="erm">!?LEx/y/l; x/y/l = координаты события
!!IF:M^Я дам твоим никчёмным Чародеям способность не получать ответа в бою, ибо ты осилил эту скучную статейку^;
!!EA136:B12/1/102/82/0/0/0/0/0/1/1/1/1/1/1; дать способность Безответный</script></p>
<p>&nbsp;<br>&nbsp;<br>&nbsp;</p></div>
<script src="../erm.js"></script></body></html>